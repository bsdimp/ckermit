List of known bugs or problems with C-Kermit under VAX/VMS:

Version: 4D(067)
As of: Thu Jan 12 20:27:33 1989

See CKUKER.BWR which lists problems with Unix Kermit.  Many of these
problems may also apply to VMS C-Kermit.  This file lists only those that
are unique to VMS C-Kermit.

Recent checkout of 4D(067) on a VAX/VMS 4.3 system gives the following results:

- The commands mostly seem to work -- help, log, set, show, etc etc.

- The basic file transfer and server commands seem to work OK with a couple
  exceptions: "remote cwd" makes the VMS C-Kermit server respond with a wierd
  message.  Text and binary files transfer OK with regular and long packets,
  with CRC's, etc etc, except that when VMS sends a foreign binary file back
  to you, it's padded out to the nearest block with nulls.

- Caution is needed with the "!" command.  If it requires a response, the 
  program will hang silently.  E.g. if you say "! delete foo.x;*" instead of
  "! delete/noconfirm foo.x;*".

- C-Kermit on VMS doesn't accept command line arguments (maybe there's a
  way to tell DCL to pass them?).

- The program doesn't seem to work when parity is involved, even if you
  "set term/parity=odd" or whatever.  The command parser goes catatonic,
  and files don't seem to transfer either.

- The command parser is totally screwy if you enter the VMS system via CTERM
  (DECnet terminal service from a DEC-20) -- characters echo twice, editing
  characters don't work, etc.  All this works fine if you enter via a regular
  terminal line.  Don't know what happens over LAT, or SET HOST between VMS
  systems, etc.

- ^C^C during file transfer doesn't interrupt the program.  Is VMS swallowing
  them?

General problems:

- The fact that VMS C-Kermit is built with CKU* files as well as CKC* and
  CKV* files is confusing.  Well...  It's that way because VAX-11 C does
  its best to provide a Unix programming environment -- to the extent it
  succeeds, VMX C-Kermit can use certain Unix-specific modules.

- VMS C-Kermit, unlike Bliss Kermit, is NOT interruptible,
  either with ^C or ^Y.  The latter can be interrupted by two (?) ^Ys.
  This is a serious shortcoming.  (There is code whose intention is
  make the program interruptible, but it apparently does not work.)

- VMS C-Kermit is less efficient than Bliss Kermit, and may require
  the use of lower baud rates when sending TO it.

- If using LAT (Local Area Transport) terminal connections, you may
  need to use a lower baud rate when transferring from your "terminal"
  to the host, or a smaller send-packet length.  Some LAT software doesn't
  expect "fast typing" from the terminal direction (applies mainly to
  old F11-based LAT boxes; newer DECserver-100s and -200s reportedly work fine
  with Kermit, if set up with the right parameters).

- VMS VAX-11 C V2 allows DEFINEs by a command line qualifer, and CKVKER.COM
  makes use of this to include debugging and transaction logging code if
  it believes that VAX-C V2 is being used.  VAX-C V1 had no such feature.
  If you want the DEBUG and TLOG symbols defined for use with VAX-C V1,
  modify the CKCDEB.H file.

- The local "directory" command defaults to * rather than *.*.

- Execution of local commands (C-Kermit>! <command>): 

The problem with "! XXX" in VMS is related to the BYTLM in user authorization
file.  For VMS to create a subprocess, the BYTLM must exceed 4096 (which is our
previous setting), and of course, PRCLM must be at least 1.  6144 seems to
work for BYTLM.

Here's some material dealing with older releases, which may still apply:

------------------------------

Date: Fri, 16 Jan 87 14:34:01 pst
From: ames!styx!elxsi!gumby.ARPA!valid!carolf@cad.Berkeley.EDU
To: CU20B.COLUMBIA.EDU!SY.FDC

I've begun to test c-kermit 4D(061) between the S-320 and the MicroVAX, running
VAX version 2.1, and the VAX-11/780 running VMS 4.4.  I compiled c-kermit on
VMS using the CKVKER.COM DCL procedure.  I've found the following problems:

 -----------------------------------------------------------------------------
 S-320 -> MicroVAX and VAX-11/780
 -----------------------------------------------------------------------------

* Bye doesn't work
  When running kermit from VMS in server mode, type bye, then connect.
  Kermit will connect to the VMS command interpreter rather than logging out
  of the server.  At this point, type logout (which doesn't echo on the screen)
 
* Exit doesn't always work (MicroVAX only)
  Sometimes no action will be taken in response to exit.  Quit always works
  however.

 -----------------------------------------------------------------------------
 MicroVAX and VAX-11/780 -> S-320
 -----------------------------------------------------------------------------

* Directory doesn't work on VMS
  Directory listed only some of the files in a directory containing several
  files.  Problem is that "dir" defaults to "." rather than "*.*".
  This can be fixed in ckuusr.c.

* On the VAX, kermit's output overwrites the prompt and command on the previous
  line.

* Remote directory on the VAX could not list UNIX files whose format was not
  correct VMS format.
  c-kermit(VAX-11/780)> remote directory
  c-kermit(VAX-11/780)> - ttini: ttiosb.status:  %SYSTEM-W-DATAOVERUN, data
  overrun (for all filenames too long)

UUCP address:  ucbvax!hplabs!pesnta!valid!carolf

                                  Carol Fernihough

------------------------------

Date: 17 Sep 87 12:23:00 MST
From: <darieb@sandia-2.arpa>
Subject: 4E C_Kermit on VAX/VMS

I've just downloaded the newest XK* versions to VAX VMS 4.5.  It compiled
without a hitch, using the XKVKER.COM.  It even transferred a file OK.  
However, there are a couple of problems:

-   The show command produces a lot of unprintable characters in the
    header lines of the table ("send" and "receive"), after which
    several of the lines contain gibberish.  After the SHOW, things go 
    back to normal (except see below)

-   After many commands are executed, and the C_Kermit> prompt shows, 
    typing another command responds with ?invalid - xxx.  Typing an 
    erase-line character (CTRL-U on VMS) before doing anything else
    will erase 3 characters of the prompt, indicating that three charac-
    ters must have been received by VMS from the terminal(?)  I can easily
    get around this problem by habitually typing <CTRL-U>command...but who
    wants to?

Is it possible that I need to SET TERMINAL to something different before
executing Kermit?  Or are there indeed spurious characters being sent by
C_Kermit?  At any rate, this version works OK, but the BLISS version is
the system standard here.

Declan A. Rieb, Division 2614		DARIEB@SANDIA-2.ARPA
Sandia National Laboratories		(505) 844-6338
Albuquerque, NM 87185-5800

------------------------------

Date: Thu 17 Sep 87 15:48:24-EDT
From: Frank da Cruz <SY.FDC@CU20B.COLUMBIA.EDU>
Subject: Re: 4E C_Kermit on VAX/VMS
To: darieb@SANDIA-2.ARPA

How are you connected to the VMS system?  Normal TTY line?  Or some kind of
terminal server or SET HOST, etc?  I tried both ways (on a VMS 4.3 system) and
found that the screen looked fine with a regular TTY line, and there were all
kinds of garble, character doubling, prompt-erasing, etc, when I came in
thru a network.  Can you give more details about your connection, the VMS
version, and maybe do a SHOW TERM?  Thanks!  - Frank

------------------------------

Date: 17 Sep 87 15:17:00 MST
From: <darieb@sandia-2.arpa>
Subject: Re: 4E C_Kermit on VAX/VMS

Boy, was that a quick reply!!!!

We're running VMS 4.5.  I'm running an IBM PC/XT at 9600 Baud using the
VTERM 4010 Version 2.0 software from Coefficient Systems Corporation, which
supplies a pretty good VT102 emulation.  Connection is through COM1: to a 
Gandalf LDS120 line driver, into a Gandalf (I think) port contender device,
thence to a VAX 8600.  No other DECNET.  The BLISS version of KERMIT works
OK.  (My connection to the CDC VX/VE which runs this KERMIT OK was through
identically the same topology, except for the final step...)

Using the PC, I was able to copy what happened onto disk.  I am forwarding it
to you below.  The funny characters, which show in VMS EDT as <+->, showed on
my PC screen as pillows.  Kermit's normal output seems to be interspersed 
between these.  The gibberish starts after the packet length data.  After
executing the SHOW, I immediately tried two STAT's.  The first worked, the
second didn't.  It's the second which I can cure by prepending the line-
cancel character <ctrl-u>.  None of this happens, using the same terminal/
parameters, when using the BLISS Kermit, nor, I believe, the previous version
of C_Kermit.

The following is what I saw and did using KERMIT:
C-Kermit>show

C-Kermit, 4E(066) 4 Aug 87, Vax/VMS, Communications Parameters:
1 1L1i1n1e1:1 1T1T1:1,1 1s1p1e1e1d1:1 1-111,1 1m1o1d1e1:1 1r1e1m1o1t1e1,1 1m1o1d
1e1m1-1d1i1a1l1e1r1:1 1d1i1r1e1c1t1
 1 1B1i1t1s1:1 181,1 1p1a1r1i1t1y1:1 none, duplex: full, flow: xon/xoff, handsha
ke: none
Terminal emulation: 7 bits

Protocol Parameters:   Send    Receive
 Timeout:               10        7
 Padding:                0        0        Block Check:      1
 Pad Character:          0        0        Delay:            5
 Packet Start:           1        1        Max Retries:     10
 Packet End:            13       13
 Packet Length:         90       90
Krti l riii akLg  sa:n     astoLg o

?Invalid -
C-Kermit>stat

Most recent transaction --
 files: 0
 total file characters  : 0
 communication line in  : 0
 communication line out : 0
 elapsed time           : 0 sec

C-Kermit>stat

?Invalid - stat
C-Kermit>exit

$ show terminal
Terminal: _VTA665:    Device_Type: VT102         Owner: Declan Rieb
Physical terminal: _TXB1:                     Username: DARIEB

   Input:   9600      LFfill:  0      Width:  80      Parity: None
   Output:  9600      CRfill:  5      Page:   24

Terminal Characteristics:
   Interactive        Echo               Type_ahead         No Escape
   Hostsync           TTsync             Lowercase          Tab
   Wrap               Scope              Remote             No Eightbit
   Broadcast          No Readsync        No Form            Fulldup
   Modem              No Local_echo      Autobaud           Hangup
   No Brdcstmbx       DMA                Altypeahd          Set_speed
   Line Editing       Overstrike editing No Fallback        Dialup
   No Secure server   Disconnect         No Pasthru         No Syspassword
   No SIXEL Graphics  No Soft Characters Printer port       Numeric Keypad
   ANSI_CRT           No Regis           No Block_mode      Advanced_video
   Edit_mode          DEC_CRT            No DEC_CRT2

Declan A. Rieb				DARIEB@SANDIA-2.ARPA
Division 2614				(505) 844-6338
Sandia National Laboratories
Albuquerque NM 87185-5800

------------------------------

Date: 17 SEP 1987  15:57 EDT
From: Steve Roseman <LUSGR@LEHICDC1.BITNET>
Subject: C-Kermit 4E(067) on VAX/VMS

Running C-Kermit 4E(067) under VMS V4.5 seems to work so far, with 3 problems.

1.  The user needs a BYTLM quota of at least 5000 to execute a "! xxx" command,
    "DIR", or "SPACE".  Otherwise the job just hangs up.

2.  With a sufficient BYTLM, the above work, but if any are done, C-Kermit
    leaves behind a subprocess when it exits.  Re-entering C-Kermit and
    executing any of the above starts up (and then leaves behind again)
    another subprocess.  Repeat until your job hangs up.

3.  A "! LOGOUT" command kills the subprocess in which it executes;  another
    "! xxx" command just hangs, since C-Kermit doesn't seem to know it's
    gone.

    Fairly minor problems, but file transfers run well with 1000 char packets.

                                                      Steve Roseman
                                                      Lehigh Univ.

------------------------------

Date: 19 Oct 87 10:49:00 EDT
From: "ETD1::LABOVITZ" <labovitz%etd1.decnet@afwal-aaa.arpa>
Subject: VMS 4.6 Bug Report with C-Kermit 4E(067)
Keywords: VAX/VMS Kermit, C-Kermit

I have just compiled the source modules for C-Kermit 4E(067) under VAX/VMS 4.6
on our VAX 11/785, using the supplied XMVKER.COM file.  During the final
link of the KERMIT executable, the following warning message is produced
by the linker:
	%LINK-W-MULDEF, symbol SYSTEM multiply defined
		in module C$UNIX file SYS$COMMON:[SYSLIB]VAXCRTL.OLB;1

While I have not had a chance to confirm this with our DEC Software Analyst
(he's on vacation until next week), this seems to be directly attributable
to the new VMS 4.6 C Run Time Library.  

Other than producing a warning message, however, our new version of KERMIT
seems to be running well thus far.  If any other problems arise, I will forward
them to Info-Kermit, otherwise it will soon replace our current version
of KERMIT-32.

					LT Stuart Labovitz
				arpa:	LabovitzSL@Afwal-aaa.ARPA
				arpa:	Labovitz%Etd1.DECNET@Afwal-aaa.ARPA
 
------------------------------

From: schullman%aqua.DEC@decwrl.dec.com (Dan Schullman
 * {617-46,29}7-4576 * MRO1-2/E47)
Date: 27 Oct 87 09:43
Subject: VMS Kermit

Frank,

	How you been?  I recently had need for KERMIT (after not using
	it for over a year), then I end up helping somebody else in my
	group with it, and then I get some internet mail about it!  When
	it rains it pours [frogs]!

	Anything going on with the C version of KERMIT?  I haven't checked,
	but believe it does not support the "new" VMS V4 file names and
	types which may be much longer and also contain hyphens and dollar-
	signs and underscores.

	Also thinking it might make more sense to use a VMS logical for
	the init file.  If you "speak" DCL, it would be something like:

		IF F$TRNLNM("KERMRC") .EQS. " " THEN GOTO IGNORE_INIT_FILE
		I_SPEC = F$PARSE("KERMRC","SYS$DISK:[].INI",,,"SYNTAX_ONLY")
		IF I_SPEC .EQS. "" THEN GOTO IGNORE_BAD_INIT_SPEC
		I_FILE = F$SEARCH(I_SPEC)
		IF I_FILE .NES. "" THEN GOTO FOUND_INIT_FILE
		I_SPEC = F$PARSE("KERMRC","SYS$LOGIN:.INI",,,"SYNTAX_ONLY")
		IF I_SPEC .EQS. "" THEN GOTO IGNORE_BAD_INIT_SPEC
		I_FILE = F$SEARCH(I_SPEC)
		IF I_FILE .NES. "" THEN GOTO FOUND_INIT_FILE
		GOTO INIT_FILE_NOT_FOUND

	This would allow:

		KERMRC to be a VMS logical that pointed at an init file:
			DEFINE  KERMRC  SYS$LOGIN:TTA3_AT_2400_BAUD.KINIT

		System (or group) defaults for init files (with user-defined
		logical having precedence):
			DEFINE/SYSTEM  KERMRC  ...
			DEFINE/GROUP   KERMRC  ...
		
		Ability to ignore system/group/job/process predefined logicals:
			DEFINE  KERMRC  " "	!a single space

		In the absence of KERMRC logical, look first for KERMRC.INI
		in current directory and if that doesn't exist look for it
		in SYS$LOGIN.

		If KERMRC is not a full file spec, supply defaults of
			SYS$DISK:[]KERMRC.INI		(first try)
			SYS$LOGIN:KERMRC.INI		(second try)
		For example:
			DEFINE  KERMRC  COLUMBIA
		would try:
			SYS$DISK:[]COLUMBIA.INI		(first attempt)
			SYS$LOGIN:COLUMBIA.INI		(second attempt)
		but
			DEFINE  KERMRC  KERMIT$DIR:.2400
		would only try (because directory was specified):
			KERMIT$DIR:KERMRC.2400

	You sufficiently confused now?  Unfortunately it would NOT be
	backwards compatible with the old name of KERMIT.INI, but I feel
	it would be more more useful.  The current code also looks first
	in SYS$LOGIN rather than the current directory.  The "new"
	approach could allow directory-specific init (e.g., file-type).
	You could take the DCL code above, add the necessary labels and
	have them display the spec and resulting file, and try it.  For
	example:

		$TRY_ANOTHER:
		$	READ SYS$COMMAND VALUE /PROMPT="Value for KERMRC: "
		$	DEFINE/NOLOG KERMRC "''VALUE'"
		$	IF VALUE .EQS. "-" THEN DEASSIGN KERMRC
		$!
		$!	put code from above in here, prefixed with "$"
		$!
		$IGNORE_INIT_FILE:
		$	WRITE SYS$OUTPUT "No init file will be used."
		$	GOTO TRY_ANOTHER
		$IGNORE_BAD_INIT_SPEC:
		$	WRITE SYS$OUTPUT "Bad spec (",I_SPEC,") ignored."
		$	GOTO TRY_ANOTHER
		$FOUND_INIT_FILE:
		$	WRITE SYS$OUTPUT "Spec: ",I_SPEC,"  File: ",I_FILE
		$	GOTO TRY_ANOTHER
		$etc...

	Comments?  Suggestions?  I don't know how soon I'd get these changes
	made.  Between family, house, and work I'm pretty busy!

						Be well,
						  Dan S.

------------------------------

Date: Tue, 10 Nov 87 14:44 CST
From: <MCGUIRE%GRIN2.BITNET@CUVMA.COLUMBIA.EDU>
Subject: RE: VMS 4.6 Bug Report with C-Kermit 4E(067)
Keywords: C-Kermit, VMS Kermit

> Date: 19 Oct 87 10:49:00 EDT
> From: "ETD1::LABOVITZ" <labovitz%etd1.decnet@afwal-aaa.arpa>
> Subject: VMS 4.6 Bug Report with C-Kermit 4E(067)
>
> I have just compiled the source modules for C-Kermit 4E(067) under VAX/VMS
> 4.6 on our VAX 11/785, using the supplied XMVKER.COM file.  During the
> final link of the KERMIT executable, the following warning message is
> produced by the linker:
>
>     %LINK-W-MULDEF, symbol SYSTEM multiply defined
>         in module C$UNIX file SYS$COMMON:[SYSLIB]VAXCRTL.OLB;1
>
> While I have not had a chance to confirm this with our DEC Software Analyst
> (he's on vacation until next week), this seems to be directly attributable
> to the new VMS 4.6 C Run Time Library.
>
> [Ed. - Thanks for the report.  It's been forwarded to the new C-Kermit/VMS
> developer and added to the XKVKER.BWR file.  Since compilation and linking
> were tested with VAX-11 C 2.3 on VMS 4.6, and this problem didn't arise,
> the culprit is indeed most likely the runtime system.]

Was C-Kermit/VMS really tested under VMS V4.6?  Before VMS V4.6, there was
no `system' function in the VAX C runtime library.  Starting with VMS V4.6,
Digital provides a `system' function.  The error message basically
indicates that the linker was provided with two routines named `system'.
It sounds like the developer of C-Kermit/VMS implemented `system' in the
code, and that it now conflicts with the new V4.6 standard `system'.

It should be straightforward for VMS V4.6 users to remove the definition
of `system' from the C-Kermit/VMS code and recompile/relink.  Perhaps the
developer can find some nifty way to define `system' conditionally
depending upon which VMS version is being used.

Ed

------------------------------

Date: 2 Feb 88 21:01:00 EST
From: "FRODO::CHERRY" <cherry%frodo.decnet@mghccc.harvard.edu>
Subject: Log session fix for VMS and CKERMIT

Here is a fix for C-Kermit on VMS systems. The session log will not work
as distributed. The fix is simple. In file ckvfio.c change the two
occurences of "fp[n]->_file" to "fileno(fp[n])". This is obviously not
the best solution as fileno is called everytime the zsoutx() and zchout()
functions are called. Perhaps this can be changes in the next version. 
I know this problem exists in C-Kermit versions from 4D(061) to 4E(070), 
but presumably in older versions as well.

line #232 was:
return(write(fp[n]->_file,s,x));
change to:
return(write(fileno(fp[n]),s,x));

line #241 was:
return(write(fp[n]->_file,&c,1)); /* Use unbuffered for session log */
change to:
return(write(fileno(fp[n]),&c,1)); /* Use unbuffered for session log */

Mike Cherry      Dept. of Molecular Biology, Mass. General Hospital, Boston
cherry@husc4.harvard.edu    or     cherry%frodo.decnet@mghccc.harvard.edu

------------------------------

Date: Tue, 22 Mar 88 18:15:49 est
From: Dick Schofield <rschofield@lucy.wellesley.edu>
To: frank_da_cruz@lucy.wellesley.edu, rschofield@lucy.wellesley.edu
Subject: VMS C-Kermit 4E(069)

I've not seen mentioned in any of the INFO-KERMIT digests of a problem
with VMS C-Kermit 4E(069) session logging.  We're just not able to
capture a log.

A sample session might look like:

	LOG SESSION SESSION.LOG
	CONNECT
	do our thing
	CLOSE SESSION	(we've tried omitting this step as well)
	EXIT

We get a file named SESSION.LOG, but it contains 0 bytes.

Second problem:

Neither BYE nor LOGOUT server commands accomplish anything at the
server end.  Though I've seen this mentioned in the INFO-KERMIT
digest, I'm not sure what the solution is.

Last problem (very, very minor, but thought you'd like to know):

If (and only if) a KERMIT.INI file exists, when you EXIT, your VMS
prompt overlays the last C-Kermit> prompt because (I think) of a
missing linefeed (following the existing carriage-return).

-----

We're extremely pleased with this latest version.  Using extended
length packets (of 1000 chars), we quite regularly get an effective
baud rate of 4900-5000 baud on a 4800 baud link -- through DEC
terminal servers yet!

Dick Schofield
Director of Academic Computing
Wellesley College
Wellesley, MA 02181
(617) 235-0320 Ext. 3107
RSCHOFIELD@LUCY.WELLESLEY.EDU (Internet)

------------------------------

Date: Wed 20 Apr 88 15:42:14-PDT
From: Ted Shapin <BEC.SHAPIN@ECLA.USC.EDU>
Subject: Fixes for C-Kermit 4E(70) for VMS
To: info-kermit@CU20B.COLUMBIA.EDU
Phone: (714)961-3393; Mail:Beckman Instruments, Inc.
Mail-addr: 2500 Harbor Blvd., X-11, Fullerton CA 92634

Here are two fixes for C-Kermit 4E(70) we made for our
VAX VMS system.
Fixes are from Will Wood, Beckman Instruments, Fullerton, CA.
- - - - - - - -
*
* here is the 2 edits for ckvfio.c
*
************
File METHODS:[WKWOOD.KERMIT]CKVFIO.C;9
    1   char *ckzv = "VMS file support, 1.0(012), 20 APR 88";
    2   char *ckzsys = " Vax/VMS";
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVFIO.C;2
    1   char *ckzv = "VMS file support, 1.0(010), 24 Jan 88";
    2   char *ckzsys = " Vax/VMS";
************
************
File METHODS:[WKWOOD.KERMIT]CKVFIO.C;9
   24    * 011 18-apr-88 WKW (BII) Do SYS$DELPRC instead of unix kill in zkself
   25    * 012 20-apr-88 WKW (BII) make zgtdir() work..
   26    */
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVFIO.C;2
   24    */
************
************
File METHODS:[WKWOOD.KERMIT]CKVFIO.C;9
   76   #include <jpidef.h>			/* 011 for SYS$GETJPI */
   77   #include stdlib				/* 012 for getcwd */
   78
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVFIO.C;2
   74
************
************
File METHODS:[WKWOOD.KERMIT]CKVFIO.C;9
   98   static int parent_pid,master_pid;	/* 011 master pid and parent_pid */
   99   zkself() {
  100   /*
  101    011
  102   	We start a chain reaction whereby we'll loop through until we find the
  103   	top pid in the job, we'll then issue a $DELPRC call to cancel him off.
  104   */
  105       	struct { short buflen, code; char *bufadr; short *retlen; } itmlst[2];
  106   					/* 011 set up itmlst */
  107   	master_pid = 0;			/* 011 set master and parent diff. */
  108   	parent_pid = 1;
  109   	while(master_pid != parent_pid) { /* loop until done */
  110             itmlst[0].buflen = 4;		/* 011 4 bytes storage */
  111             itmlst[0].code   = JPI$_MASTER_PID; /* 011 we want the pid of our */
  112             itmlst[0].bufadr = &parent_pid; /* 011 put the parent pid here */
  113             itmlst[0].retlen = 0;
  114             itmlst[1].buflen = 0;
  115             itmlst[1].code   = 0;
  116   	  SYS$GETJPIW(0,&master_pid,0,&itmlst,0,0,0);
  117   	  if(master_pid != parent_pid) {
  118   	    master_pid = parent_pid;	/* 011 assign new master */
  119   	    parent_pid = 0;		/* 011 reset so we'll find the next */
  120   	  }
  121   	}
  122       return((SYS$DELPRC(&master_pid) & 7) == 1);	/* 011 delete the whole job */
  123   }
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVFIO.C;2
   94   zkself() {
   95       return (kill(0,9));
   96   }
************
************
File METHODS:[WKWOOD.KERMIT]CKVFIO.C;9
  259         return(write(fileno(fp[n]),s,x));
  260   }
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVFIO.C;2
  232       return(write(fp[n]->_file,s,x));
  233   }
************
************
File METHODS:[WKWOOD.KERMIT]CKVFIO.C;9
  268   	return(write(fileno(fp[n]),&c,1)); /* use unbuffered for session log */
  269       else {
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVFIO.C;2
  241       	return(write(fp[n]->_file,&c,1)); /* Use unbuffered for session log */
  242       else {
************
************
File METHODS:[WKWOOD.KERMIT]CKVFIO.C;9
  429   /* 012 make this work */
  430
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVFIO.C;2
  402
************
************
File METHODS:[WKWOOD.KERMIT]CKVFIO.C;9
  433         char cwdbuf[100];
  434         char *buf;
  435         buf = cwdbuf;
  436       return(getcwd(buf,100));
  437   }
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVFIO.C;2
  405   /*    char *getcwd();
  406   /*    char cwdbuf[100];
  407   /*    char *buf;
  408   /*    buf = cwdbuf;
  409   /*    return(getcwd(buf,100));
  410   */
  411       return("");  /* Can't seem to make LINK find getcwd()... */
  412   }
************

Number of difference sections found: 8
Number of difference records found: 40

DIFFERENCES /IGNORE=()/MERGED=1/OUTPUT=METHODS:[WKWOOD.KERMIT]CKVFIO.DIFF;1-
    METHODS:[WKWOOD.KERMIT]CKVFIO.C;9-
    METHODS:[WKWOOD.KERMIT.ORIG]CKVFIO.C;2

*
* here is the edit for ckvtio
*
************
File METHODS:[WKWOOD.KERMIT]CKVTIO.C;7
    1   char *ckxv = "VMS tty I/O, 1.0(014), 18 APR 88";
    2
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVTIO.C;1
    1   char *ckxv = "VMS tty I/O, 1.0(013), 14 Sep 87";
    2
************
************
File METHODS:[WKWOOD.KERMIT]CKVTIO.C;7
    6    * 014	18-APR-88 WKW (BII)
    7    *			Fix def of ttmode structure to correctly resemble
    8    *			data types.  CHAR was used and this caused a little
    9    *			grief.  Additionally, I have noticed that if the
   10    *			terminal calling C-KERMIT is not native (i.e.
   11    *			unknown to VMS directly,  The TTVT and TTRES
   12    *			qios will fail with a -F-BADPARAM.  If this becomes
   13    *			a problem a check at both of these to see if the
   14    *			.type == 0 then we should set it to something.
   15    *
   16    * 013 14 Sep 87 FdC    Add parity strip to ttinl(), add syscleanup().
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVTIO.C;1
    6    * 013 14 Sep 87 FdC    Add parity strip to ttinl(), add syscleanup().
************
************
File METHODS:[WKWOOD.KERMIT]CKVTIO.C;7
  110   #include <tt2def.h>			/* 014 declare it for extended funcs */
  111   #include <ssdef.h>
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVTIO.C;1
  100   #include <ssdef.h>
************
************
File METHODS:[WKWOOD.KERMIT]CKVTIO.C;7
  137   /*
  138    014 use byte references instead of char (works better for value conversion)
  139   */
  140   struct tt_mode {
  141       unsigned int class : 8, type : 8;	/* 014 class and type are ubyte */
  142       unsigned short width;		/* 014 */
  143       unsigned int basic : 24;		/* 014 */
  144       unsigned int length : 8;		/* 014 */
  145       unsigned int extended;		/* 014 */
  146   };
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVTIO.C;1
  126
  127   struct tt_mode {
  128       char class, type;
  129       short width;
  130       int basic : 24;
  131       char length;
  132       long extended;
  133   };
************
************
File METHODS:[WKWOOD.KERMIT]CKVTIO.C;7
  228   		 &ttold, sizeof(ttold), 0, 0, 0, 0))) return(-1);
  229
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVTIO.C;1
  215   		 &ttold, sizeof ttold, 0, 0, 0, 0))) return(-1);
  216
************
************
File METHODS:[WKWOOD.KERMIT]CKVTIO.C;7
  277       		 &ttold, sizeof(ttold), 0, 0, 0, 0))) return(-1);
  278       return(0);
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVTIO.C;1
  264       		 &ttold, sizeof ttold, 0, 0, 0, 0))) return(-1);
  265       return(0);
************
************
File METHODS:[WKWOOD.KERMIT]CKVTIO.C;7
  309       	    	 &ttraw, sizeof(ttraw), s, 0, 0, 0))) return(-1);
  310       ttflui();				/* Flush any pending input */
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVTIO.C;1
  296       	    	 &ttraw, sizeof ttraw, s, 0, 0, 0))) return(-1);
  297       ttflui();				/* Flush any pending input */
************
************
File METHODS:[WKWOOD.KERMIT]CKVTIO.C;7
  335   			  &ttraw, sizeof(ttraw), s, 0, 0, 0))) return(-1);
  336   }
******
File METHODS:[WKWOOD.KERMIT.ORIG]CKVTIO.C;1
  322   			  &ttraw, sizeof ttraw, s, 0, 0, 0))) return(-1);
  323   }
************

Number of difference sections found: 8
Number of difference records found: 25

DIFFERENCES /IGNORE=()/MERGED=1/OUTPUT=METHODS:[WKWOOD.KERMIT]CKVTIO.DIFF;1-
    METHODS:[WKWOOD.KERMIT]CKVTIO.C;7-
    METHODS:[WKWOOD.KERMIT.ORIG]CKVTIO.C;1

------------------------------

Date: Sat, 21 May 88 14:39:59 EDT
From: elsie!ado@ncifcrf.gov (Arthur David Olson)
Subject: RE: VAX C-Kermit Over X.25 PADs
Keywords: C-kermit

Re: Info-Kermit Digest V7 #12:

> We have a (*very* slow) VAX-11/780 running VMS 4.7; terminals connected to 
> X25 PADs and make X29 calls into the VAX. We have all our lines set for 9600
> baud. C-Kermit works OK with normal packet sizes, and it sends files *to* the
> PC with 250 byte packets OK. However, trying to use any packet size about 200
> bytes or so *from* the PC results in repeated retries; the log shows that the
> VAX is giving "Data Overrun" errors on about 1 in 3 packets.

The same sort of thing happens with PCs connected via DZ11s; the VAX just
can't drain the DZ11's silo fast enough, resulting in silo overflow.

So. . .here at elsie we don't even try; we've set MAXRP to 94.

   *** 1.1/ckcker.h	Sat May 21 14:37:26 1988
   --- 1.4/ckcker.h	Sat May 21 14:37:28 1988
   ***************
   *** 26,31 ****
   --- 26,35 ----
     
     #define MAXSP 2048			/* Send packet buffer size  */
     #define MAXRP 1024			/* Receive packet buffer size  */
   + #ifndef ASWAS
   + #undef MAXRP
   + #define MAXRP 94			/* ...or suffer buffer overruns */
   + #endif /* !defined ASWAS */
     #define MAXWS 1				/* Maximum window size */
     
     /* Kermit parameters and defaults */
-- 
    Canada's program is to spaceflight as the carrier pigeon is to mail.
	ado@ncifcrf.gov			ADO is a trademark of Ampex.

------------------------------

Date: Tue 12 Jul 88 10:32:38-PDT
From: Ted Shapin <BEC.SHAPIN@ECLA.USC.EDU>
Subject: Possible C-kermit bug
Phone: (714)961-3393; Mail:Beckman Instruments, Inc.
Mail-addr: 2500 Harbor Blvd., X-11, Fullerton CA 92634

In C-KERMIT 4E(070) for Vax/VMS I can start it on the VAX,
do a CWD one time, but after that first time, if I try to do
another CWD, I stay in the same directory.

Has anyone seen this on (a) the VAX, (b) other systems?

Ted.

------------------------------

Date: Tue, 8 Mar 88 00:13:01 est
From: Brendan Reilly <reilly@aqua.whoi.edu>
Site: Woods Hole Oceanographic Institution, Woods Hole Mass.
Subject: Problem with latest version of C-KERMIT on VMS
Keywords: C-Kermit and VMS

After compiling KERMIT with the latest CC from Digital it appears that both
KERMIT and VMS/CC have a procedure named system.  I've changed the KERMIT
reference to vms_system, but I'm still having a problem with server mode.
When talking to the VMS side in server mode from a PC running the latest
KERMIT and I issue a REMOTE CWD [reilly.a] I'm asked for a password, to
which I reply with a return and then see some garbage characters typed on
the screen.  If I then do a REMOTE DIR it's a surprise to find that I'm
still in the original directory - not [REILLY.A] Has anyone else seen this?

[Ed. - There's definitely some kind of bug in VMS C-Kermit in this area.
When I try this, the VMS C-Kermit server goes into an infinite unstoppable
loop printing messages issued by its "ttinl()" function: "SYS$QIOW:
%SYSTEM-F-EXQUOTA, exceeded quota", and "%NONAME-W-NOMSG, Message number 0".
Another one for the bug list.]

------------------------------

Date: Wed, 08 Jun 88 10:04:12 EST
From: PIQUE%UCONNVM.BITNET@MITVMA.MIT.EDU
Subject: C-Kermit 4E(070) under Vax/VMS using parity

I compiled C-Kermit 4E(070) under Vax/VMS, using version 1.0(013) of the VMS
tty I/O module, CKVTIO.C.  The fixes present to make it work properly when
parity is being used didn't work properly because ttprty was never set in
CKVTIO.C.  Here's a partial fix:

************
File DUB1:[COMMON.C-KERMIT]CKVTIO.C;2
   53      ttpkt(speed,flow,parity)-- Put the tty in packet mode and set the spe
   54      ttvt(speed,flow)        -- Put the tty in virtual terminal mode.
******
File DUB1:[COMMON.C-KERMIT]CKVTIO.C;1
   53      ttpkt(speed,flow)       -- Put the tty in packet mode and set the spe
   54      ttvt(speed,flow)        -- Put the tty in virtual terminal mode.
************
************
File DUB1:[COMMON.C-KERMIT]CKVTIO.C;2
  279   ttpkt(speed,flow,parity) int speed, flow, parity; {
  280       extern char ttname[];
******
File DUB1:[COMMON.C-KERMIT]CKVTIO.C;1
  279   ttpkt(speed,flow) int speed, flow; {
  280       extern char ttname[];
************
************
File DUB1:[COMMON.C-KERMIT]CKVTIO.C;2
  283       ttprty = parity;                 /* Let other tt functions see this.
  284       debug(F101,"ttpkt setting ttprty","",ttprty);
  285       s = ttsspd(speed);            /* Check the speed */
******
File DUB1:[COMMON.C-KERMIT]CKVTIO.C;1
  283       s = ttsspd(speed);            /* Check the speed */
************

Number of difference sections found: 3
Number of difference records found: 4

DIFFERENCES /IGNORE=()/MERGED=1/OUTPUT=DUB1:[COMMON.C-KERMIT]DIFF.LIS;1-
    DUB1:[COMMON.C-KERMIT]CKVTIO.C;2-
    DUB1:[COMMON.C-KERMIT]CKVTIO.C;1


This doesn't fix things completely since the call to SYS$QIOW in ttinl()
waiting for an end-of-line character waits for an end-of-line character
with high bit 0, but if (say) end-of-line is 13 and parity is even it
should really be waiting for a character with high bit set (X'8D').
However you can work around this by choosing the end-of-line character
so that it is sent with high bit reset (e.g., eol=15 for even parity).

Another problem is that data overrun errors occur periodically during
file transfer and (at times) during terminal emulation.  Kermit
will also sometimes lock up completely during terminal emulation.
I do not know what is causing this.  We are running on a MicroVax II
with BYTLM=20480.

David Moews                 PIQUE@UCONNVM.BITNET

------------------------------

Date: Tue, 19 Jul 88 13:54 CDT
From: <ARCHERB%UMKCVAX1.BITNET@CUVMB.CC.COLUMBIA.EDU> (BARRY ARCHER)
Subject: Changes for VMS C-Kermit

        In working with the VMS version of C-Kermit, I became frustrated with
the problems with hanging subprocesses after exiting the image, as well as the
problems I was having running C-Kermit while connected to a DECserver ( LAT
protocol ).  I finally figured out how to fix those problems and installed the
new version.

        After a few weeks a user complained that they were unable to
transfer a file, change directories and then transfer another file - this
was with the VAX in server mode.  I found this was due to the use of a
subprocess for some commands and the parent process for others, including
the file transfers.  The environments were not staying consistant,
particularily if one tried REMOTE HOST SET DEF as well as REMOTE CWD, since
they each modified different process enviroments.

        I had already discovered that REMOTE HOST HELP caused the VAX
processes to hang ( the VMS mailboxes just can't handle it ), so I had been
parsing all remote host commands to trap any VMS help commands.  First I got
the zchdir() function working properly & had it tell the subprocess to
change to the same directory, thereby keeping them in synch.  Then I trapped
REMOTE HOST SET DEFAULT and re-routed it to zchdir().

        The changes I've made are:

        1. CKUUSR.C - changed the [local] DIR command to execute as if it were
a shell command, i.e.

	C-Kermit> dir == C-Kermit> ! dir

This helps take care of a buffering problem over LAT virtual terminal ports.
The change is within a vax11c define.

        2. CKUCMD.C - added a vax11c define in the parser.  getchar() can
return an XON or XOFF when using a LAT, so I added a check for that, and if
found, another call to getchar() is made.  This helps a lot.  Until I found
this, I coudn't figure out why I kept getting invalid command errors when it
looked fine to me!

        3. CKVFIO.C - I tried to keep all major changes to the system dependant
module.

          a) zkself() - I found I didn't need anything longer than just a
call to SYS$DELPRC(0L,0L).  I saw an earlier diff file with a more
complicated search and destroy check of subprocesses, but I found this was
all I needed.  ( I do have some changes that allow only one subprocess to
exist at a time. )  Also, the variables for child_pid and mailboxes are made
visible to the whole module.

          b) zclose() - this is where subprocesses weren't getting closed,
so I added a check, which if true triggers a call to zclosf() to kill the
subprocess.

          c) zdelet() - now returns the result of the delete command.

          d) zchdir() - Defaults to current dir.  If there is a subprocess
and the directory was successfully changed, the subprocess is forced to
change to the same directory.  This keeps the two in environmental synch.

          e) zgtdir() - returns getcwd().  Made the buffer static, so we're
not returning a pointer to garbage.

          f) zxcmd() - Now refuses to do HELP or EDIT, since these hang
everything.  Check for SET DEFAULT - no point in changing it in the
subprocess but not the parent.  So I simply call zchdir(), which
functionally is the same & now changes both environments.  I also check for
DELETE, since if the user has DELETE redefined as DELETE/CONFIRM in VMS we
also hang.  Decided the simplest thing was to call delet() rather than
construct a string and pass that on to the subprocess ( this has one
possible bad effect - a version number is no longer required, defaulting to
the most recent version.  Some VMS users may not like that ).

          g) zkillf() - small change to make it work properly.

          h) system() - no need for it since VAX C 2.3 has a system() function.

        I am going to try to mail the changed modules to you, as well as to
info-kermit.  There should be the three: CKUUSR.C, CKUCMD.C and CKVFIO.C

I forgot I made one slight change to CKCFNS.C to make a cleaner tlog:
************
File SYS_DISK:[ARCHERB.KERMIT.CKERM]CKCFNS.C;10
 1141    /* do tlog AFTER ending vdir with a null */
 1142    tlog(F110,"Directory requested: ",(vdir+1),0l);
 1143    if (zchdir(vdir+1)) {
 1144    cdd = zgtdir(); /* Get new working directory. */
 1145    tlog(F110,"Changed directory to",cdd,0l);
 1146    encstr(cdd);
 1147    ack1(data);
 1148    return(1);
******
File SYS_DISK:[ARCHERB.KERMIT.CKERM.OLDC]CKCFNS.C;1
 1142    if (zchdir(vdir+1)) {
 1143    cdd = zgtdir(); /* Get new working directory. */
 1144    encstr(cdd);
 1145    ack1(data);
 1146    tlog(F110,"Changed directory to",cdd,0l);
 1147    return(1);
************

        We just set up a version of C-Kermit to use a LAT virtual port to
connect to a modem on a DECserver, so I am starting to look at the CKVTIO.C
and CKVCON.C modules.  The only thing serious I've found so far is that the
DIAL command doesn't work ( and might not be able to over the LAT ).

        Let me know if there is anything else you might want me to work on.


                        Barry Archer
                        archerb@umkcvax1.bitnet

------------------------------

Date:     Tue, 19 Jul 88 14:11 CDT
From:     <ARCHERB%UMKCVAX1.BITNET@CUVMB.CC.COLUMBIA.EDU> (BARRY ARCHER)
Subject:  CKVFIO.C with changes

char *ckzv = "VMS file support, 1.0(010), 24 Jan 88";
char *ckzsys = " Vax/VMS";

/* C K V F I O  --  Kermit file system support for VAX/VMS */

/* Stew Rubenstein, Harvard University Chemical Labs */
/*  (c) 1985 President and Fellows of Harvard College  */
/*  Based on CKZUNX.C, 4.1(015) 28 Feb 85 */
/* Also, Martin Minow (MM), Digital Equipment Corporation, Maynard MA */
/* Also, Dan Schullman (DS), Digital Equipment Corporation, Maynard MA */
/* Adapted from ckufio.c, by... */
/* F. da Cruz (FdC), Columbia University Center for Computing Activities */

/* Edit history
 * 003 20-Mar-85 MM  fixed fprintf bug in zsout.c
 * 004 21-Mar-84 MM  create text files in variable-stream.
 * 005  8-May-85 MM  filled in zkself (not tested), fixed other minor bugs
 * 006  5-Jul-85 DS  handle version number in zltor, zrtol
 * 007 11-Jul-85 FdC fix zclose() to give return codes
 * 008 19-Mar-86 FdC Fix system() for "!", zopeni() for REMOTE commands.
 * 008 17-Sep-87 FdC Define PWDCMD.
 * 090 (???)
 * 010 24-Jan-88 FdC Add zgtdir() function, even tho it doesn't work...
 */

/* Definitions of some VMS system commands */

char *DIRCMD = "DIRECTORY ";            /* For directory listing */
char *DELCMD = "DELETE ";               /* For file deletion */
char *TYPCMD = "TYPE ";                 /* For typing a file */
char *SPACMD = "DIRECTORY/TOTAL";       /* Space/quota of current directory */
char *SPACM2 = "DIRECTORY/TOTAL ";      /* Space/quota of current directory */
char *WHOCMD = "SHOW USERS";            /* For seeing who's logged in */
char *PWDCMD = "SHOW DEFAULT";          /* For seeing current directory */

/*
  Functions (n is one of the predefined file numbers from ckermi.h):

   zopeni(n,name)   -- Opens an existing file for input.
   zopeno(n,name)   -- Opens a new file for output.
   zclose(n)        -- Closes a file.
   zchin(n)         -- Gets the next character from an input file.
   zsout(n,s)       -- Write a null-terminated string to output file, buffered.
   zsoutl(n,s)      -- Like zsout, but appends a line terminator.
   zsoutx(n,s,x)    -- Write x characters to output file, unbuffered.
   zchout(n,c)      -- Add a character to an output file, unbuffered.
   zchki(name)      -- Check if named file exists and is readable, return size.
   zchko(name)      -- Check if named file can be created.
   znewn(name,s)    -- Make a new unique file name based on the given name.
   zdelet(name)     -- Delete the named file.
   zxpand(string)   -- Expands the given wildcard string into a list of files.
   znext(string)    -- Returns the next file from the list in "string".
   zxcmd(cmd)       -- Execute the command in a lower fork.
   zclosf()         -- Close input file associated with zxcmd()'s lower fork.
   zrtol(n1,n2)     -- Convert remote filename into local form.
   zltor(n1,n2)     -- Convert local filename into remote form.
   zchdir(dirnam)   -- Change working directory.
   zhome()          -- Return pointer to home directory name string.
   zkself()         -- Log self out
 */

/* Includes */

#include "ckcker.h"
#include "ckcdeb.h"
#include <stdio.h>
#include <ctype.h>
#include <rms.h>
#include <descrip.h>
#include <dvidef.h>
#include <iodef.h>
#include <errno.h>
#include <signal.h>
#include stdlib

#define MAXWLD 500                      /* Maximum wildcard filenames */


/* Declarations */

FILE *fp[ZNFILS] = {                    /* File pointers */
    NULL, NULL, NULL, NULL, NULL, NULL, NULL };

static int fcount;                      /* Number of files in wild group */
char *getenv(), *strcpy();              /* For finding home directory */

static char *mtchs[MAXWLD],             /* Matches found for filename */
     **mtchptr;                         /* Pointer to current match */

static int input_mbxchn, output_mbxchn, child_pid = 0;

/***  Z K S E L F --  Log self out  ***/

/*** this works in VMS) ***/

zkself() {
    return (SYS$DELPRC(0L,0L));         /* delete self */
}

/*  Z O P E N I  --  Open an existing file for input. */

zopeni(n,name) int n; char *name; {
    debug(F111," zopeni",name,n);
    debug(F101,"  fp","",(int) fp[n]);
    if (n == ZSYSFN) {                  /* Input from a system function? */
        return(zxcmd(name));            /* Try to fork the command */
    }
    if (n == ZSTDIO) {                  /* Standard input? */
        if (isatty(0)) {
            fprintf(stderr,"?Terminal input not allowed\n");
            debug(F110,"zopeni: attempts input from unredirected stdin","",0);
            return(0);
        }
        fp[ZIFILE] = stdin;
        return(1);
    }
    if (chkfn(n) != 0) return(0);
    fp[n] = fopen(name,"r");            /* Real file. */
    debug(F111," zopeni", name, (int) fp[n]);
    if (fp[n] == NULL) perror(name);    /* +1, want a useful message    */
    return((fp[n] != NULL) ? 1 : 0);
}

/*  Z O P E N O  --  Open a new file for output.  */

zopeno(n,name) int n; char *name; {

    int fildes;
    extern int binary;

    debug(F111," zopeno",name,n);
    if (chkfn(n) != 0) return(0);
    if ((n == ZCTERM) || (n == ZSTDIO)) {   /* Terminal or standard output */
        fp[ZOFILE] = stdout;
        debug(F101," fp[]=stdout", "", (int) fp[n]);
        return(1);
    }
    /*
     * Create "binary" output files as fixed-block 512 byte records.
     * This should permit copying task images.  It is rumored that
     * Vax C will null-fill an incomplete final block.
     *
     * Create all debugging files (and normal output files) in
     * "vanilla" RMS -- variable length, implicit carriage control.
     * This way, old brain-damaged programs aren't suprised by
     * bizarre Unix-styled files.
     */
    if (n == ZOFILE && binary != 0)
        fildes = creat(name, 0, "mrs=512", "rfm=fix");
    else
        fildes = creat(name, 0, "rat=cr", "rfm=var");
    fp[n] = (fildes == -1) ? NULL : fdopen(fildes, "w");
    if (fp[n] == NULL) perror(name);            /* +1, print useful msg */
/*    if (n == ZDFILE && isatty(fileno(fp[n])))
        setbuf(fp[n],NULL);  */
/* Make debugging file unbuffered */
    debug(F101, " fp[n]", "", (int) fp[n]);
    return((fp[n] != NULL) ? 1 : 0);
}

/*  Z C L O S E  --  Close the given file.  */

/*  Returns 0 if arg out of range, 1 if successful, -1 if close failed.  */

zclose(n) int n; {
    int x;
    if (chkfn(n) < 1) return(0);
    if ((child_pid != 0) && ((fp[n] == 0) || (n == ZSYSFN))) {
        x = zclosf();
    } else {
        if ((fp[n] != stdout) && (fp[n] != stdin)) x = fclose(fp[n]);
        fp[n] = NULL;
    }
    return((x == EOF) ? -1 : 1);
}

/*  Z C H I N  --  Get a character from the input file.  */

static int subprocess_input = 0, sub_count;
static char *sub_ptr, sub_buf[100];

get_subprc_line() {
    struct { short status, size, trm, trmsize; } subiosb;
    if ((SYS$QIOW(0, output_mbxchn, IO$_READVBLK, &subiosb, 0, 0,
                sub_buf, sizeof(sub_buf), 0, 0, 0, 0) & 7) != 1
        || (subiosb.status & 7) != 1) return(-1);
    if (subiosb.size == 29
     && strncmp(sub_buf, ">>> END OF KERMIT COMMAND <<<",
                subiosb.size) == 0) {
        subprocess_input = 0;
        return(-1);
    }
    sub_buf[subiosb.size] = '\n';
    sub_buf[subiosb.size + 1] = '\0';
    sub_count = subiosb.size;
    sub_ptr = sub_buf;
    return(0);
}

zchin(n,c) int n; char *c; {
    int a;
    if (n == ZIFILE && subprocess_input) {
        if (--sub_count < 0)
            if (get_subprc_line()) return(-1);
        a = *sub_ptr++;
    } else {
        if (chkfn(n) < 1) return(-1);
        a = getc(fp[n]);
    }
    if (a == EOF) return(-1);
    *c = (a & 0377);
    return(0);
}

/*  Z S O U T  --  Write a string to the given file, buffered.  */

zsout(n,s) int n; char *s; {
    if (chkfn(n) < 1) return(-1);
    fputs(s, fp[n]);                    /* Don't use fprintf here MM */
    return(0);
}

/*  Z S O U T L  --  Write string to file, with line terminator, buffered  */

zsoutl(n,s) int n; char *s; {
    if (chkfn(n) < 1) return(-1);
    fputs(s, fp[n]);                    /* Don't use fprintf MM */
    putc('\n', fp[n]);
    return(0);
}

/*  Z S O U T X  --  Write x characters to file, unbuffered.  */

zsoutx(n,s,x) int n, x; char *s; {
    if (chkfn(n) < 1) return(-1);
    return(write(fileno(fp[n]),s,x));
}


/*  Z C H O U T  --  Add a character to the given file.  */

zchout(n,c) int n; char c; {
    if (chkfn(n) < 1) return(-1);
    if (n == ZSFILE)
        return(write(fileno(fp[n]),&c,1)); /* Use unbuffered for session log */
    else {
        if (putc(c,fp[n]) == EOF)       /* If true, maybe there was an error */
            return(ferror(fp[n]));      /* Check to make sure */
        else                            /* Otherwise... */
            return(0);                  /* There was no error. */
    }
}

/*  C H K F N  --  Internal function to verify file number is ok  */

/*
 Returns:
  -1: File number n is out of range
   0: n is in range, but file is not open
   1: n in range and file is open
*/
chkfn(n) int n; {
    switch (n) {
        case ZCTERM:
        case ZSTDIO:
        case ZIFILE:
        case ZOFILE:
        case ZDFILE:
        case ZTFILE:
        case ZPFILE:
        case ZSFILE: break;
        default:
            debug(F101,"chkfn: file number out of range","",n);
            fprintf(stderr,"?File number out of range - %d\n",n);
            return(-1);
    }
    return( (fp[n] == NULL) ? 0 : 1 );
}

/*  Z C H K I  --  Check if input file exists and is readable  */

/*
  Returns:
   >= 0 if the file can be read (returns the size).
     -1 if file doesn't exist or can't be accessed,
     -2 if file exists but is not readable (e.g. a directory file).
     -3 if file exists but protected against read access.
*/
/*
 For Berkeley Unix, a file must be of type "regular" to be readable.
 Directory files, special files, and symbolic links are not readable.
*/
long
zchki(name) char *name; {
    int x; long pos;

    x = open(name, 0);
    if (x < 0) {
        debug(F111,"zchki stat fails",name,errno);
        return(-1);
    }
    pos = lseek(x, 0, 2);
    close(x);
    return(pos);
}

/*  Z C H K O  --  Check if output file can be created  */

/*
 Returns -1 if write permission for the file would be denied, 0 otherwise.
*/
zchko(name) char *name; {
    return(0);                          /* Always creates new version */
}

/*  Z D E L E T  --  Delete the named file.  */

zdelet(name) char *name; {
    return(delete(name) == 0);
}


/*  Z R T O L  --  Convert remote filename into local form  */

/*  For VMS, we eliminate all special characters and truncate.  */
/*  Doesn't allow the longer filespecs that VMS V4 supports.    */
/*  Assumes version number delimited by semicolon, not period.  */
/*  Should really use RMS to parse filespec components.  -- DS  */

zrtol(name,name2) char *name, *name2; {
    int count;
    char *cp;

    count = 9;
    for ( cp = name2; *name != '\0'; name++ ) {
        switch (*name) {
            case '.':                   /* File type */
                count = 3;              /* Max length for this field */
                *cp++ = '.';
                break;
            case ';':                   /* Version */
                count = 5;
                *cp++ = ';';
                break;
            default:
                if (count > 0 && isalnum(*name)) {
                    --count;
                    *cp++ = islower(*name) ? toupper(*name) : *name;
                }
                break;
        }
    }
    *cp = '\0';                         /* End of name */
    debug(F110,"zrtol: ",name2,0);
}

/*  Z L T O R  --  Convert filename from local format to common form.   */

zltor(name,name2) char *name, *name2; {
    char *cp, *pp;

    for (cp = pp = name; *cp != '\0'; cp++) {   /* strip path name */
        if (*cp == ']' || *cp == ':') {
            pp = cp;
            pp++;
        }
    }
    for ( ; --cp >= pp; ) {             /* From end to beginning */
        if (!isdigit(*cp)) {            /* if not numeric, then */
            if (*cp == '-') --cp;       /* if minus sign, skip over, or */
            if (*cp == ';') *cp = '\0'; /* if version delim, make end */
            break;
        }
    }
    cp = name2;                         /* If nothing before dot, */
    if (*pp == '.') *cp++ = 'X';        /* insert 'X' */
    strcpy(cp,pp);

    debug(F110,"zltor: ",name2,0);
}

/*  Z C H D I R  --  Change directory  */

zchdir(dirnam) char dirnam[]; {

    char   *zgtdir();
    char   dir_buff[200];
    int    status;

    if (dirnam[0] == '\0')
        strcpy(dirnam,"[]");            /* default to current dir */
    else
     {
        status = chdir(dirnam);         /* change first in parent proc */
        /* then change it in the child process -> keep in synch! */
        if ((child_pid != 0) && (status == 0))
           {    /* construct command for child proc */
                strcpy(dir_buff,"$ set def ");
                strcat(dir_buff,zgtdir());
                SYS$QIOW(0, input_mbxchn, IO$_WRITEVBLK | IO$M_NOW, 0, 0, 0,
                        dir_buff, strlen(dir_buff), 0, 0, 0, 0);
           }
        return(status == 0);
     }
}

/*  Z H O M E  --  Return pointer to user's home directory  */

char *
zhome() {
    return(getenv("HOME"));
}

static char cwdbuf[100];  /* lets make this static, eh */

/*  Z G T D I R  --  Return pointer to user's current directory  */

char *
zgtdir() {

return(getcwd(cwdbuf,100));     /* now we just return curr dir specs */

}

/*  Z X C M D -- Run a system command so its output can be read like a file */

zxcmd(comand) char *comand; {
    char input_mbxnam[10], output_mbxnam[10];
    char cmdbuf[200];
    char test_str[256];
    char *sptr;
    int  i;

        /* convert to uppercase */
    for (i=0;i<=strlen(comand);i++)
        *(comand+i) = toupper(*(comand+i));

/* VMS HELP hangs the subprocess, so lets avoid it */
    strcpy(test_str,comand);
    if (strncmp(test_str,"HELP",4) == NULL)
        return(-1);                             /* can't do remote host help */
/* VMS EDT hangs the subprocess, so lets avoid it */
    strcpy(test_str,comand);
    if ((strncmp(test_str,"EDIT",4) == NULL) ||
        (strncmp(test_str,"EDT",3) == NULL))
           return(-1);                          /* can't do remote host edt */

/* we will have to do a SET DEFAULT as a CWD or we get confusion between
        parent and child process as to what directory we're in!
*/
    strcpy(test_str,comand);
    debug(F110,"zxcmd: ",test_str,0);
    if (strncmp(test_str,"SET DEF",7) == NULL)
       {
        sptr = &test_str[7];
        while ((*sptr != ' ') && (*sptr != NULL))
                sptr++;     /* find directory spec */
        if (*sptr++ != NULL)
           {    /* try to cwd */
                debug(F110,"zxcmd: ",sptr,0);
                return(zchdir(sptr));
           }
       }
/* Now we have to check for DELETE, since if user has DELETE/CONFIRM set
 then the child process will hang everything waiting for the confirmation
 that will never come.  So a little more robust to use delete function via
 the parent process.
*/
    if (strncmp(test_str,"DEL",3) == NULL)
       {        /* this is a delete file command string */
                sptr = &test_str[3];
                while ((*sptr != ' ') && (*sptr != NULL))
                        sptr++;     /* find file spec */
                if (*sptr++ != NULL)
                   {    /* try to delete */
                        debug(F110,"zxcmd (del): ",sptr,0);
                        return(zdelet(sptr));
                   }
        }

/* otherwise, go ahead with passing command to child to execute */

    if (child_pid == 0) {
        struct dsc$descriptor_s inpdsc, outdsc;
        struct { short buflen, code; char *bufadr; short *retlen; } itmlst[2];

        SYS$CREMBX(0, &input_mbxchn, 0, 0, 0, 0, 0);
        itmlst[0].buflen = sizeof input_mbxnam;
        itmlst[0].code   = DVI$_DEVNAM;
        itmlst[0].bufadr = input_mbxnam;
        itmlst[0].retlen = 0;
        itmlst[1].buflen = 0;
        itmlst[1].code   = 0;
        SYS$GETDVI(0, input_mbxchn, 0, itmlst, 0, 0, 0, 0);
        SYS$WAITFR(0);

        SYS$CREMBX(0, &output_mbxchn, 0, 0, 0, 0, 0);
        itmlst[0].buflen = sizeof output_mbxnam;
        itmlst[0].bufadr = output_mbxnam;
        SYS$GETDVI(0, output_mbxchn, 0, itmlst, 0, 0, 0, 0);
        SYS$WAITFR(0);

        inpdsc.dsc$w_length  = strlen(input_mbxnam);
        inpdsc.dsc$b_dtype   = DSC$K_DTYPE_T;
        inpdsc.dsc$b_class   = DSC$K_CLASS_S;
        inpdsc.dsc$a_pointer = input_mbxnam;

        outdsc.dsc$w_length  = strlen(output_mbxnam);
        outdsc.dsc$b_dtype   = DSC$K_DTYPE_T;
        outdsc.dsc$b_class   = DSC$K_CLASS_S;
        outdsc.dsc$a_pointer = output_mbxnam;

        LIB$SPAWN(0, &inpdsc, &outdsc, &1, 0, &child_pid);
        SYS$QIOW(0, input_mbxchn, IO$_WRITEVBLK | IO$M_NOW, 0, 0, 0,
            "$ SET NOON", 10, 0, 0, 0, 0);

    }

    strcpy(cmdbuf, "$ ");
    strcat(cmdbuf, comand);
    SYS$QIOW(0, input_mbxchn, IO$_WRITEVBLK | IO$M_NOW, 0, 0, 0,
            cmdbuf, strlen(cmdbuf), 0, 0, 0, 0);
    SYS$QIOW(0, input_mbxchn, IO$_WRITEVBLK | IO$M_NOW, 0, 0, 0,
            "$ WRITE SYS$OUTPUT \">>> END OF KERMIT COMMAND <<<\"",
            50, 0, 0, 0, 0);
    subprocess_input = 1;
    sub_count = 0;
    return(1);
}

/*  Z C L O S F  - close the suprocess output file.  */

zclosf() {
   zkillf();
}

/*  Z K I L L F  - kill the subprocess used for host commands  */
/*  The return value is 1 if the subprocess was killed successfully. */
/*                      -1 if there was no subprocess to kill, */
/*                      or error code if can't delete process. */

zkillf() {
    int sys_stat;

    if (child_pid == 0)
        return(-1);

/*      must use SYS$DELPRC() since we used SYS$CREPRC() to create subproc
*/
    if ((sys_stat = SYS$DELPRC(&child_pid,0L)) == SS$_NORMAL)
        child_pid = 0;
    return(sys_stat);

}

/*  Z X P A N D  --  Expand a wildcard string into an array of strings  */
/*
  Returns the number of files that match fn1, with data structures set up
  so that first file (if any) will be returned by the next znext() call.
*/
zxpand(fn) char *fn; {
    fcount = fgen(fn,mtchs,MAXWLD);     /* Look up the file. */
    if (fcount > 0) {
        mtchptr = mtchs;                /* Save pointer for next. */
    }
    debug(F111,"zxpand",mtchs[0],fcount);
    return(fcount);
}


/*  Z N E X T  --  Get name of next file from list created by zxpand(). */
/*
 Returns >0 if there's another file, with its name copied into the arg string,
 or 0 if no more files in list.
*/
znext(fn) char *fn; {
    if (fcount-- > 0) strcpy(fn,*mtchptr++);
    else *fn = '\0';
    debug(F111,"znext",fn,fcount+1);
    return(fcount+1);
}


/*  Z N E W N  --  Make a new name for the given file  */

znewn(fn,s) char *fn, **s; {
    static char buf[100];
    char *bp, *xp;
    int len = 0, n = 0, d = 0, t;

    strcpy(buf, fn);                    /* Version numbers are handled by OS */
    *s = buf;
}

/*  Wildcard expansion for VMS is easy;  we just use a run-time library call.
*/
fgen(pat,resarry,len)
char *pat,*resarry[];
int len;
{
    struct dsc$descriptor_s file_spec, result, deflt;
    long context;
    int count, slen, status, plen;
    char *pp, *rp, result_string[256], *strchr();

    file_spec.dsc$w_length  = strlen(pat);
    file_spec.dsc$b_dtype   = DSC$K_DTYPE_T;
    file_spec.dsc$b_class   = DSC$K_CLASS_S;
    file_spec.dsc$a_pointer = pat;

    result.dsc$w_length  = sizeof result_string;
    result.dsc$b_dtype   = DSC$K_DTYPE_T;
    result.dsc$b_class   = DSC$K_CLASS_S;
    result.dsc$a_pointer = result_string;

    deflt.dsc$w_length  = 3;
    deflt.dsc$b_dtype   = DSC$K_DTYPE_T;
    deflt.dsc$b_class   = DSC$K_CLASS_S;
    deflt.dsc$a_pointer = "*.*";

    count = 0;
    context = 0;
    pp = strchr(pat, ']');
    if (pp == 0) pp = strchr(pat, ':');
    if (pp == 0) plen = 0;
    else plen = pp - pat + 1;
    while (count < len
           && (status = LIB$FIND_FILE(&file_spec, &result, &context, &deflt))
                == RMS$_NORMAL) {
        rp = strchr(result_string, ']') + 1;
        slen = strchr(rp, ' ') - rp;
        resarry[count] = malloc(slen + plen + 1);
        if (plen != 0)
            strncpy(resarry[count], pat, plen);
        strncpy(resarry[count] + plen, rp, slen);
        resarry[count][slen + plen] = '\0';
        ++count;
    }
#ifdef DVI$_ALT_HOST_TYPE
    lib$find_file_end(&context);        /* Only on V4 and later */
#endif
    if (status == RMS$_FNF) return(0);
    if (status == RMS$_NMF) return(count);
    return(-1);
}

/*      don't need this under VAX/VMS C v2.3    */
/*
system(s)  char *s;  {
    struct dsc$descriptor_s cmd;

    if ( *s ) {
        zxcmd(s);
        while (!get_subprc_line())
            fputs(sub_buf, stdout);
        putchar('\n');
    } else {
        LIB$SPAWN();
    }
}
*/

------------------------------

Date: Tue, 19 Jul 88 14:07 CDT
From: <ARCHERB%UMKCVAX1.BITNET@CUVMB.CC.COLUMBIA.EDU> (BARRY ARCHER)
Subject: Changes to ckuusr.c
Keywords:

        This is the change that makes DIR work with LAT connections ( and also
automatically defaults to current dir...

case XXDIR:                             /* directory */
#ifdef vax11c
    if ((x = cmtxt("Directory/file specification","",&s)) < 0) return(x);
    /* now do this the same as a shell command - helps with LAT  */
    conres();           /* make console normal */
    lp = line;
    sprintf(lp,"%s %s",DIRCMD,s);
    debug(F110,"Directory string: ", line, 0);
    system(line);
    concb(escape);
    return(0);
#else
#ifdef AMIGA
    if ((x = cmtxt("Directory/file specification","",&s)) < 0) return(x);
#else
#ifdef datageneral
    if ((x = cmtxt("Directory/file specification","+",&s)) < 0) return(x);
#else
    if ((x = cmtxt("Directory/file specification",".",&s)) < 0) return(x);
#endif
#endif
    lp = line;
    sprintf(lp,"%s %s",DIRCMD,s);
    system(line);
    return(0);
#endif

                                        BarryA

------------------------------

Date: Tue, 19 Jul 88 14:09 CDT
From: <ARCHERB%UMKCVAX1.BITNET@CUVMB.CC.COLUMBIA.EDU> (BARRY ARCHER)
Subject: Changes to ckucmd.c
Keywords:

The change is to gtword(), throw away any spurious XONs or XOFFs.  This is
also for smooth LAT use...

gtword() {

    int c;                              /* Current char */
    static int inword = 0;              /* Flag for start of word found */
    int quote = 0;                      /* Flag for quote character */
    int echof = 0;                      /* Flag for whether to echo */
    int ignore = 0;

#ifdef datageneral
    extern int termtype;                /* DG terminal type flag */
    extern int con_reads_mt;            /* Console read asynch is active */
    if (con_reads_mt) connoi_mt();      /* Task would interfere w/cons read */
#endif

    pp = np;                            /* Start of current field */
    debug(F101,"gtword: cmdbuf","",(int) cmdbuf);
    debug(F101," bp","",(int) bp);
    debug(F101," pp","",(int) pp);
    debug(F110," cmdbuf",cmdbuf,0);

    while (bp < cmdbuf+CMDBL) {         /* Loop */

        ignore = echof = 0;             /* Flag for whether to echo */

        if ((c = *bp) == NUL) {         /* Get next character */
            if (dpx) echof = 1;         /* from reparse buffer */
#ifdef datageneral
            {
               char ch;
               c = dgncinb(0,&ch,1);    /* -1 is EOF, -2 TO,
                                         * -c is AOS/VS error */
               if (c == -2) {           /* timeout was enabled? */
                    resto(channel(0));  /* reset timeouts */
                    c = dgncinb(0,&ch,1); /* retry this now! */
               }
               if (c < 0) return(-4);    /* EOF or some error */
               else c = (int) ch & 0177; /* Get char without parity */
               echof = 1;
            }
#else
            c = getchar();              /* or from tty. */
#ifdef vax11c
                /* necessary for LAT terminals, avoid spurious XON,XOFF */
            while ((c == 17) || (c == 19))
                c = getchar();
#endif
            if (c == EOF) {
/***            perror("ckucmd getchar");  (just return silently) ***/
                return(-4);
            }
#endif
        } else ignore = 1;

        if (quote == 0) {

            if (!ignore && (c == '\\')) { /* Quote character */
               quote = 1;
               continue;
            }
            if (c == FF) {              /* Formfeed. */
                c = NL;                 /* Replace with newline */
#ifdef apollo
                putchar(FF);
#else
#ifdef AMIGA
                putchar(FF);
#else
#ifdef datageneral
                putchar(FF);
#else
                system("clear");        /* and clear the screen. */
#endif
#endif
#endif
            }

            if (c == HT) c = SP;        /* Substitute space for tab. */

/* cont'd... */

                        BarryA

------------------------------

Date: Fri, 12 Aug 88 07:44 EST
From: "CHEMB::SKITA"@a.chem.upenn.edu
Subject: CKERMIT

The following is a report of a severe bug observed in version C-Kermit, 4E(070)
29 Jan 88, Vax/VMS. 

Kermit-C has been compiled and linked on a  VAX 8200 (VMS 4.7). A note
concerning the compilation and linking: My current C Run Time Library is
VAXCRTL.OLB (V2 lib). However, if I link (as does ckvker.com) with this library
and use the /DEFINE=("DEBUG","TLOG") qualifier during compilation, Kermit-C
crashes during the my test while attempting to write to debug.log. If I compile
without the /DEFINE qualifier, and link with VAXCRTL.OLB, Kermit executes
without crashing, however (of course) a debug.log file is not written. I have
not investigated the "crash", however I have a "access violation" in module
CKUUS3; I will give you a detailed report at a later time.  For the purposes
of my test I did not compile with the /DEFINE qualifier.

For the purposes of this test, the HOST and REMOTE machines are the same, as is
the version of Kermit. Kermit is set-up as follows: 

C-Kermit, 4E(070) 29 Jan 88, Vax/VMS, 
Communications Parameters:

Line: ker$term, speed: 1200, mode:local, modem-dialer: direct 
Bits: 8, parity:none, duplex: full, flow: xon/xoff, handshake: none

Terminal emulation: 7 bits

Protocol Parameters:   Send    Receive
 Timeout:               10        7                    
 Padding:                0        0
 Block Check:      1
 Pad Character:          0        0
 Delay:            5
 Packet Start:           1        1
 Max Retries:     10
 Packet End:            13       13
 Packet Length:         90       90
 Length Limit:        2048     1024

File parameters:
File Names: converted        File Type:    text    Packet Log:       packet.log
File Warning: off            Session Log: session.log
File Display: on                                       

File Byte Size: 8, Incomplete File Disposition: discard, Init file: kermit.ini

I am attempting to send the following three lines of ASCII code after which
I timeout. This is very reproducible. As you know, I have encountered this
same problem with Kermit-VMS.

********************************START OF FILE********************************
        BLBS    R0,10$
        RET                                     ; Return if error
10$:    MOVC5   #80,INFAB,#0,#FABLEN,TEMPFAB
*********************************END OF FILE*********************************

The following is the packet.log file from the HOST Kermit.


********************************START OF FILE********************************
s-0 Sz* @-#Y1~"  z>
r-0 Yz* @-#Y1~"  zD
s-+!FBUG.FILE 
r-*!YTMP.MARE"  z
s-y"D~( BLBS~$ R0,10$#M#J~( RET~E ; R
eturn if error#M#J10$:~$ MOVC5~# ##80,INFAB,##0,##FABLN
s-(resend)
r-y"D~( BLBS~$ R0,10$#M#J~( RET~E ; Re
Command too long
> OC5~# ##80,INFAB,##0,##FABLN
s-(resend)
s-(resend)
r-y"D~( BLBS~$ R0,10$#M#J~( RET~E ; Re
Command too long
> VC5~# ##80,INFAB,##0,##FABLN
s-(resend)
s-(resend)
r-y"D~( BLBS~$ R0,10$#M#J~( RET~E ; Re
Command too long
> OVC5~# ##80,INAB,##0,##FABLN
s-(resend)
s-(resend)
r-y"D~( BLBS~$ R0,10$#M#J~( RET~E ; Re
Command too long
> OVC5# ##80,INFAB,##0,##FABLN
s-(resend)
s-(resend)
r-y"D~( BLBS~$ R0,10$#M#J~( RET~E ; Re
Command too long
> OVC~# ##80,INFAB,##0,##FABLN
s-(resend)
s-(resend)
r-y"D~( BLBS~$ R0,10$#M#J~( RET~E ; Re
Command too long
> OVC5~# #80,INFAB,##0,##FABLN
*********************************END OF FILE*********************************

The following is the packet.log from the REMOTE Kermit.

********************************START OF FILE********************************
s-# N
s-(resend)
r-0 Sz* @-#Y1~"  z>
s-0 Yz* @-#Y1~"  zD
r-+!FBUG.FILE   z
s-*!YTMP.MARE
s-(resend)
s-(resend)
s-(resend)
s-(resend)
s-(resend)
s-(resend)
s-(resend)
s-(resend)
*********************************END OF FILE*********************************

Thank you.
Victor Skita  <skita@uconnvm.bitnet>
              <skita%b.chem@upenn.edu>

------------------------------

Date: 2 Nov 1988 0946-EST
From: hsw@tycho.arpa  (Howard Weiss)
Subject: Problem with C-Kermit (server mode) on VMS.
Keywords: C-Kermit 4E(070)

I've got c-kermit version 4E(070) running on VAX/VMS 4.7 and it seems to work
fine (especially after increasing BYTELM to get the DIR and SPACE commands to
work - thanks to the .bwr file) except when the VMS side is running in server
mode.  I can transfer files to and from VMS from my SUN, but then there is a
problem when issuing the BYE command from the SUN to the VMS server.  BYE
causes the server to logout and go back to DCL, but the terminal
characteristics are NOT restored (i.e., the terminal is left in noecho,
passall, nottsync, eightbit, etc). I use the FINISH command which leaves
causes VMS to leave server mode but continue running kermit, the terminal
characteristics are OK.

Are there any words of wisdom?

Howard Weiss

------------------------------

