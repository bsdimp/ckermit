
/* WARNING -- This C source program generated by Wart preprocessor. */
/* Do not edit this file; edit the Wart-format source file instead, */
/* and then run it through Wart to produce a new C source file.     */

/* Wart Version Info: */
char *wartv = "Wart Version 1A(006) Jan 1989";

char *protv = "C-Kermit Protocol Module 4F(034), 19 Jun 89"; /* -*-C-*- */

/* C K C P R O  -- C-Kermit Protocol Module, in Wart preprocessor notation. */
/*
 Author: Frank da Cruz (fdc@columbia.edu, FDCCU@CUVMA.BITNET),
 Columbia University Center for Computing Activities.
 First released January 1985.
 Copyright (C) 1985, 1989, Trustees of Columbia University in the City of New 
 York.  Permission is granted to any individual or institution to use, copy, or
 redistribute this software so long as it is not sold for profit, provided this
 copyright notice is retained. 
*/
#include "ckcdeb.h"
#include "ckcker.h"
/*
 Note -- This file may also be preprocessed by the Unix Lex program, but 
 you must indent the above #include statements before using Lex, and then
 restore them to the left margin in the resulting C program before compilation.
 Also, the invocation of the "wart()" function below must be replaced by an
 invocation  of the "yylex()" function.  It might also be necessary to remove
 comments in the %%...%% section.
*/

/* State definitions for Wart (or Lex) */
#define ipkt 1
#define rfile 2
#define rattr 3
#define rdata 4
#define ssinit 5
#define ssfile 6
#define ssattr 7
#define ssdata 8
#define sseof 9
#define sseot 10
#define serve 11
#define generic 12
#define get 13
#define rgen 14

/* External C-Kermit variable declarations */
  extern char sstate, *versio, *srvtxt, *cmarg, *cmarg2, *rpar();
  extern char data[], filnam[], srvcmd[], ttname[], *srvptr;
  extern int pktnum, timint, nfils, hcflg, xflg, speed, flow, mdmtyp;
  extern int prvpkt, cxseen, czseen, server, local, displa, bctu, bctr, quiet;
  extern int tsecs, parity, backgrd, nakstate, atcapu;
  extern int putsrv(), puttrm(), putfil(), errpkt();
  extern CHAR *rdatap, recpkt[];
  extern char *DIRCMD, *DELCMD, *TYPCMD, *SPACMD, *SPACM2, *WHOCMD;
  extern struct zattr iattr;

/* Local variables */
  static char vstate = 0;  		/* Saved State   */
  static char vcmd = 0;    		/* Saved Command */
  int x;				/* General-purpose integer */
  char *s;				/* General-purpose string pointer */

/* Macros - Note, BEGIN is predefined by Wart (and Lex) as "state = ", */
/* BEGIN is NOT a GOTO! */
#define SERVE  tinit(); BEGIN serve
#define RESUME if (server) { SERVE; } else { sleep(2); return; }


#define BEGIN state =

int state = 0;

wart()
{
    int c,actno;
    extern CHAR tbl[];
    while (1) {
	c = input();
	if ((actno = tbl[c + state*128]) != -1)
	    switch(actno) {
case 1:
    { tinit();	    	    	    	/* Do Send command */
    if (sinit()) BEGIN ssinit;
       else RESUME; }
    break;
case 2:
    { tinit(); BEGIN get; }
    break;
case 3:
    { tinit(); vstate = get;  vcmd = 0;   sipkt('I'); BEGIN ipkt; }
    break;
case 4:
    { tinit(); vstate = rgen; vcmd = 'C'; sipkt('I'); BEGIN ipkt; }
    break;
case 5:
    { tinit(); vstate = rgen; vcmd = 'G'; sipkt('I'); BEGIN ipkt; }
    break;
case 6:
    { sleep(1); SERVE; }
    break;
case 7:
    { errpkt("User cancelled transaction"); /* "ABEND" -- Tell other side. */
    return(0); }
    break;
case 8:
    {			/* Receive Send-Init packet */
    rinit(rdatap);			/* Set parameters */
    bctu = bctr;			/* Switch to agreed-upon block check */
    resetc();				/* Reset counters */
    rtimer();				/* Reset timer */
    BEGIN rfile;			/* Go into receive-file state */
}
    break;
case 9:
    {				/* Get ack for I-packet */
    spar(rdatap);			/* Set parameters */
    if (vcmd) {				/* If sending a generic command */
	scmd(vcmd,cmarg);		/* Do that */
	vcmd = 0;			/* and then un-remember it. */
    }
    if (vstate == get) srinit();	/* If sending GET command, do that */
    BEGIN vstate;			/* Switch to desired state */
}
    break;
case 10:
    {				/* Ignore Error reply to I packet */
    if (vcmd) {				/* in case other Kermit doesn't */
	scmd(vcmd,cmarg);		/* understand I-packets. */
	vcmd = 0;			/* Otherwise act as above... */
    }
    if (vstate == get) srinit();
    BEGIN vstate;
}
    break;
case 11:
    {		/* Resend of previous I-pkt ACK, same seq number! */
    srinit();
}
    break;
case 12:
    {				/* Get I-packet */
    spar(rdatap);			/* Set parameters from it */
    ack1(rpar());			/* Respond with our own parameters */
    pktnum = 0;				/* Reset packet sequence numbers */
    prvpkt = -1;			/* Stay in server command wait */
}
    break;
case 13:
    {				/* Get Receive-Init */
    srvptr = srvcmd;			/* Point to server command buffer */
    decode(rdatap,putsrv);		/* Decode the GET command into it */
    cmarg = srvcmd;
    nfils = -1;				/* Initialize number of files */
    if (sinit())			/* Send Send-Init */
      BEGIN ssinit;			/* If successful, switch state */
    else { SERVE; }			/* Else back to server command wait */
}
    break;
case 14:
    {				/* Generic server command */
    srvptr = srvcmd;			/* Point to command buffer */
    decode(rdatap,putsrv);		/* Decode packet data into it */
    putsrv('\0');			/* Insert a couple nulls */
    putsrv('\0');			/* for termination */
    sstate = srvcmd[0];			/* Set requested start state */
    BEGIN generic;			/* Switch to generic command state */
}
    break;
case 15:
    {				/* Receive Host command */
    srvptr = srvcmd;			/* Point to command buffer */
    decode(rdatap,putsrv);		/* Decode command packet into it */
    putsrv('\0');			/* Null-terminate */
    if (syscmd(srvcmd,""))		/* Try to execute the command */
      BEGIN ssinit;			/* If OK, send back its output */
    else {				/* Otherwise */
	errpkt("Can't do system command"); /* report error */
	SERVE;				/* & go back to server command wait */
    }
}
    break;
case 16:
    {				/* Any other command in this state */
    errpkt("Unimplemented server function"); /* we don't know about */
    SERVE;				/* back to server command wait */
}
    break;
case 17:
    {				/* Got REMOTE CWD command */
    if (!cwd(srvcmd+1)) errpkt("Can't change directory"); /* Try to do it */
    SERVE;				/* Back to server command wait */
}
    break;
case 18:
    {				/* REMOTE DIRECTORY command */
    if (syscmd(DIRCMD,srvcmd+2))	/* If it can be done */
      BEGIN ssinit;			/* send the results back */
    else {				/* otherwise */
	errpkt("Can't list directory");	/* report failure */
	SERVE;				/* & return to server command wait */
    }
}
    break;
case 19:
    {				/* REMOTE DELETE (Erase) command */
    if (syscmd(DELCMD,srvcmd+2))	/* Try to do it */
      BEGIN ssinit;			/* If OK send results back */
    else {				/* otherwise */
	errpkt("Can't remove file");	/* report failure */
	SERVE;				/* & return to server command wait */
    }
}
    break;
case 20:
    {				/* FINISH */
    ack();				/* Acknowledge */
    screen(SCR_TC,0,0l,"");		/* Display */
    return(0);				/* Done */
}
    break;
case 21:
    {				/* BYE (LOGOUT) */
    ack();				/* Acknowledge */
    ttres();				/* Reset the terminal */
    screen(SCR_TC,0,0l,"");		/* Display */
    return(zkself());			/* Try to log self out */
}
    break;
case 22:
    {				/* REMOTE HELP */
    if (sndhlp()) BEGIN ssinit;		/* Try to send it */
    else {				/* If not ok, */
	errpkt("Can't send help");	/* send error message instead */
	SERVE;				/* and return to server command wait */
    }
}
    break;
case 23:
    {				/* REMOTE TYPE */
    if (syscmd(TYPCMD,srvcmd+2))	/* Try */
      BEGIN ssinit;			/* OK */
    else {				/* not OK */
	errpkt("Can't type file");	/* give error message */
	SERVE;				/* wait for next server command */
    }
}
    break;
case 24:
    {				/* REMOTE SPACE */
    x = *(srvcmd+1);			/* Get area to check */
    x = ((x == '\0') || (x == SP));
    x = (x ? syscmd(SPACMD,"") : syscmd(SPACM2,srvcmd+2));
    if (x)				/* If we got the info */
      BEGIN ssinit;			/* send it */
    else {				/* otherwise */
	errpkt("Can't check space");	/* send error message */
	SERVE;				/* and await next server command */
    }
}
    break;
case 25:
    {				/* REMOTE WHO */
    if (syscmd(WHOCMD,srvcmd+2))	/* The now-familiar scenario... */
      BEGIN ssinit;
    else {
	errpkt("Can't do who command");
	SERVE;
    }
}
    break;
case 26:
    {				/* Anything else in this state... */
    errpkt("Unimplemented generic server function"); /* Complain */
    SERVE;				/* and return to server command wait */
}
    break;
case 27:
    {				/* Short-Form reply */
    decode(rdatap,puttrm);		/* in ACK Data field */
    RESUME;
}
    break;
case 28:
    {				/* File header */
    xflg = 0;				/* Not screen data */
    rcvfil(filnam);			/* Figure out local filename */
    encstr(filnam);			/* Encode it */
    ack1(data);				/* Send it back in ACK */
    initattr(&iattr);			/* Clear file attribute structure */
    nakstate = 1;			/* In this state we can send NAKs */
    BEGIN rattr;			/* Now expect Attribute packets */
}
    break;
case 29:
    {				/* X-packet instead of file header */
    xflg = 1;				/* Screen data */
    ack();				/* Acknowledge the X-packet */
    initattr(&iattr);			/* Initialize attribute structure */
    nakstate = 1;			/* Say that we can send NAKs */
    BEGIN rattr;			/* Expect Attribute packets */
}
    break;
case 30:
    {				/* Attribute packet */
    if (gattr(rdatap,&iattr) == 0)	/* Read into attribute structure */
      ack();				/* If OK, acknowledge */
    else				/* If not */
      ack1("N");			/* refuse to accept the file */
}
    break;
case 31:
    {				/* First data packet */
    if (xflg)				/* If screen data */
      x = opent();			/* "open" the screen */
    else				/* otherwise */
      x = opena(filnam,&iattr);		/* open the file, with attributes */
    if (x) {				/* If file was opened ok */
	if (decode(rdatap,putfil) < 0) { /* decode first data packet */
	    errpkt("Error writing data");
	    RESUME;
	}
	ack();				/* acknowledge it */
	BEGIN rdata;			/* and switch to receive-data state */
    } else {				/* otherwise */
	errpkt("Can't open file");	/* send error message */
	RESUME;				/* and quit. */
    }
}
    break;
case 32:
    {				/* EOT, no more files */
    ack();				/* Acknowledge */
    tsecs = gtimer();			/* Get timing for statistics */
    reot();				/* Do EOT things */
    RESUME;				/* and quit */
}
    break;
case 33:
    {				/* Data packet */
    if (cxseen)				/* If file interrupt */
      ack1("X");			/* put "X" in ACK */
    else if (czseen)			/* If file-group interrupt */
      ack1("Z");			/* put "Z" in ACK */
    else if (decode(rdatap,putfil) < 0) { /* Normal case, */
	errpkt("Error writing data");	/*   decode data to file */
	RESUME;				/* Send ACK if data written */
    } else ack();			/* to file OK. */
}
    break;
case 34:
    {			/* End Of File (EOF) Packet */
    if (reof(&iattr) < 0) {		/* Close & dispose of the file */
	errpkt("Can't close file");	/* If problem, send error message */
	RESUME;				/* and quit */
    } else {				/* otherwise */
	ack();				/* acknowledge the EOF packet */
	BEGIN rfile;			/* and await another file */
    }
}
    break;
case 35:
    {				/* ACK for Send-Init */
    spar(rdatap);			/* set parameters from it */
    bctu = bctr;			/* switch to agreed-upon block check */
    x = sfile(xflg);			/* Send X or F header packet */
    if (x) {				/* If the packet was sent OK */
	resetc();			/* reset per-transaction counters */
	rtimer();			/* reset timers */
	BEGIN ssfile;			/* and switch to receive-file state */
    } else {				/* otherwise send error msg & quit */
	s = xflg ? "Can't execute command" : "Can't open file";
	errpkt(s);
	RESUME;
    }
}
    break;
case 36:
    {				/* ACK for F packet */
    srvptr = srvcmd;			/* Point to string buffer */
    decode(rdatap,putsrv);		/* Decode data field, if any */
    putsrv('\0');			/* Terminate with null */
    if (*srvcmd)			/* If remote name was recorded */
      tlog(F110," stored as",srvcmd,0); /* Record it in transaction log. */
    if (atcapu) {			/* If attributes are to be used */
	if (sattr(xflg) < 0) {		/* set and send them */
	    errpkt("Can't send attributes"); /* if problem, say so */
	    RESUME;			     /* and quit */
	} else BEGIN ssattr;		/* if ok, switch to attribute state */
    } else if (sdata() < 0) {		/* No attributes, send data */
	clsif();			/* If not ok, close input file, */
	seof("");			/* send EOF packet */
	BEGIN sseof;			/* and switch to EOF state. */
    } else BEGIN ssdata;		/* All ok, switch to send-data state */
}
    break;
case 37:
    {				/* Got ACK to A packet */
    if (rsattr(rdatap) < 0) {		/* Was the file refused? */
	clsif();			/* yes, close it */
	seof("D");			/* send EOF with "discard" code */
	BEGIN sseof;			/* switch to send-EOF state */
    } else if (sdata() < 0) {		/* File accepted, send data */
	clsif();			/* If problem, close input file */
	seof("");			/* send EOF packet */
	BEGIN sseof;			/* and switch to send-EOF state. */
    } else BEGIN ssdata;		/* All ok, enter send-data state. */
}
    break;
case 38:
    {				/* Got ACK to Data packet */
    if (canned(rdatap)) {		/* If file transfer cancelled */
	clsif();			/* close input file */
	seof("D");			/* send EOF packet with Discard code */
	BEGIN sseof;			/* switch to EOF state */
    } else if (sdata() < 0) {		/* Not cancelled, send next data */
	clsif();			/* If there was a problem close file */
	seof("");			/* Send EOF packet */
	BEGIN sseof;			/* enter send-eof state */
    }
}
    break;
case 39:
    {				/* Got ACK to EOF */
    if (gnfile() > 0) {			/* Any more files to send? */
	if (sfile(xflg))		/* Yes, try to send next file header */
	  BEGIN ssfile;			/* if ok, enter send-file state */
	else {				/* otherwise */
	    errpkt("Can't open file");	/* send error message */
	    RESUME;			/* and quit */
	}
    } else {				/* No next file */
	tsecs = gtimer();		/* get statistics timers */
	seot();				/* send EOT packet */
	BEGIN sseot;			/* enter send-eot state */
    }
}
    break;
case 40:
    {				/* Got ACK to EOT */
    RESUME;				/* All done, just quit */
}
    break;
case 41:
    {					/* Got Error packet, in any state */
    ermsg(rdatap);			/* Issue message. */
    x = quiet; quiet = 1;		/* Close files silently, */
    clsif(); clsof(1);			/* discarding any output file. */
    tsecs = gtimer();			/* Get timers */
    quiet = x;				/* restore quiet state */
    if (backgrd && !server) fatal("Protocol error");
    RESUME;
}
    break;
case 42:
    {					/* Anything not accounted for above */
    errpkt("Unknown packet type");	/* Give error message */
    RESUME;				/* and quit */
}
    break;

	    }
    }
}

CHAR tbl[] = {
-1, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42,  7, 42,  4, 42, 42, 42,  5, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42,  3,  1, 42, 42,  2, 42,  6, 42, 42, 42, 42, 42, 42, 42, 
-1, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 10, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42,  9, 42, 42, 42, 42, 42, 42, 
42,  7, 42,  4, 42, 42, 42,  5, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42,  3,  1, 42, 42,  2, 42,  6, 42, 42, 42, 42, 42, 42, 42, 
-1, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 32, 42, 42, 41, 28, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 29, 42, 42, 42, 42, 42, 42, 42, 
42,  7, 42,  4, 42, 42, 42,  5, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42,  3,  1, 42, 42,  2, 42,  6, 42, 42, 42, 42, 42, 42, 42, 
-1, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 30, 42, 42, 31, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 34, 42, 42, 42, 42, 42, 
42,  7, 42,  4, 42, 42, 42,  5, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42,  3,  1, 42, 42,  2, 42,  6, 42, 42, 42, 42, 42, 42, 42, 
-1, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 33, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 34, 42, 42, 42, 42, 42, 
42,  7, 42,  4, 42, 42, 42,  5, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42,  3,  1, 42, 42,  2, 42,  6, 42, 42, 42, 42, 42, 42, 42, 
-1, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 35, 42, 42, 42, 42, 42, 42, 
42,  7, 42,  4, 42, 42, 42,  5, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42,  3,  1, 42, 42,  2, 42,  6, 42, 42, 42, 42, 42, 42, 42, 
-1, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 36, 42, 42, 42, 42, 42, 42, 
42,  7, 42,  4, 42, 42, 42,  5, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42,  3,  1, 42, 42,  2, 42,  6, 42, 42, 42, 42, 42, 42, 42, 
-1, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 37, 42, 42, 42, 42, 42, 42, 
42,  7, 42,  4, 42, 42, 42,  5, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42,  3,  1, 42, 42,  2, 42,  6, 42, 42, 42, 42, 42, 42, 42, 
-1, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 38, 42, 42, 42, 42, 42, 42, 
42,  7, 42,  4, 42, 42, 42,  5, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42,  3,  1, 42, 42,  2, 42,  6, 42, 42, 42, 42, 42, 42, 42, 
-1, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 39, 42, 42, 42, 42, 42, 42, 
42,  7, 42,  4, 42, 42, 42,  5, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42,  3,  1, 42, 42,  2, 42,  6, 42, 42, 42, 42, 42, 42, 42, 
-1, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 40, 42, 42, 42, 42, 42, 42, 
42,  7, 42,  4, 42, 42, 42,  5, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42,  3,  1, 42, 42,  2, 42,  6, 42, 42, 42, 42, 42, 42, 42, 
-1, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
16, 16, 16, 15, 16, 16, 16, 14, 16, 12, 16, 16, 16, 16, 16, 16, 
16, 16, 13,  8, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
16,  7, 16,  4, 16, 16, 16,  5, 16, 16, 16, 16, 16, 16, 16, 16, 
16, 16,  3,  1, 16, 16,  2, 16,  6, 16, 16, 16, 16, 16, 16, 16, 
-1, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 
26, 26, 26, 17, 18, 19, 20, 26, 22, 26, 26, 26, 21, 26, 26, 26, 
26, 26, 26, 26, 23, 24, 26, 25, 26, 26, 26, 26, 26, 26, 26, 26, 
26,  7, 26,  4, 26, 26, 26,  5, 26, 26, 26, 26, 26, 26, 26, 26, 
26, 26,  3,  1, 26, 26,  2, 26,  6, 26, 26, 26, 26, 26, 26, 26, 
-1, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42,  8, 42, 42, 42, 42, 42, 11, 42, 42, 42, 42, 42, 42, 
42,  7, 42,  4, 42, 42, 42,  5, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42,  3,  1, 42, 42,  2, 42,  6, 42, 42, 42, 42, 42, 42, 42, 
 0, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42, 42, 42, 41, 28, 42, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42, 42,  8, 42, 42, 42, 42, 29, 27, 42, 42, 42, 42, 42, 42, 
42,  7, 42,  4, 42, 42, 42,  5, 42, 42, 42, 42, 42, 42, 42, 42, 
42, 42,  3,  1, 42, 42,  2, 42,  6, 42, 42, 42, 42, 42, 42, 42, 
};


/*  P R O T O  --  Protocol entry function  */

proto() {

    extern int sigint();
    int x;

    conint(sigint);			/* Enable console interrupts */

/* Set up the communication line for file transfer. */

    if (local && (speed < 0)) {
	screen(SCR_EM,0,0l,"Sorry, you must 'set speed' first");
	return;
    }

    x = -1;
    if (ttopen(ttname,&x,mdmtyp) < 0) {
	debug(F111,"failed: proto ttopen local",ttname,local);
	screen(SCR_EM,0,0l,"Can't open line");
	return;
    }
    if (x > -1) local = x;
    debug(F111,"proto ttopen local",ttname,local);

    x = (local) ? speed : -1;
    if (ttpkt(x,flow,parity) < 0) {	/* Put line in packet mode, */
	screen(SCR_EM,0,0l,"Can't condition line");
	return;
    }
    if (sstate == 'x') {		/* If entering server mode, */
	server = 1;			/* set flag, */
	if (!quiet) {
	    if (!local)			/* and issue appropriate message. */
	    	conol(srvtxt);
	    else {
	    	conol("Entering server mode on ");
		conoll(ttname);
	    }
	}
    } else server = 0;
    if (sstate == 'v' && !local && !quiet)
      conoll("Escape back to your local Kermit and give a SEND command...");
    if (sstate == 's' && !local && !quiet)
      conoll("Escape back to your local Kermit and give a RECEIVE command...");
    sleep(1);
/*
 The 'wart()' function is generated by the wart program.  It gets a
 character from the input() routine and then based on that character and
 the current state, selects the appropriate action, according to the state
 table above, which is transformed by the wart program into a big case
 statement.  The function is active for one transaction.
*/
    wart();				/* Enter the state table switcher. */
    
    if (server) {			/* Back from packet protocol. */
	server = 0;
    	if (!quiet)  			/* Give appropriate message */
	    conoll("C-Kermit server done");
    }
    ttres();
    screen(SCR_TC,0,0l,"");		/* Transaction complete */
}
